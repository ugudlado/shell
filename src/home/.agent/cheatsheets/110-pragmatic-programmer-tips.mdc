---
description:
globs:
alwaysApply: false
---
# The Pragmatic Programmer - Quick Reference

## üéØ Core Philosophy Tips

### **Tip 1: Care About Your Craft**
*Why spend your life developing software unless you care about doing it well?*

### **Tip 2: Think! About Your Work**
*Turn off the autopilot and take control. Constantly critique and appraise your work.*

### **Tip 3: Provide Options, Don't Make Lame Excuses**
*Instead of excuses, provide options. Don't say it can't be done; explain what can be done.*

### **Tip 4: Don't Live with Broken Windows**
*Fix bad designs, wrong decisions, and poor code when you see them.*

### **Tip 5: Be a Catalyst for Change**
*You can't force change on people. Instead, show them how the future might be and help them participate in creating it.*

## üß† Knowledge & Learning

### **Tip 8: Invest Regularly in Your Knowledge Portfolio**
- Learn at least one new language every year
- Read a technical book each quarter
- Read nontechnical books, too
- Take classes
- Participate in local user groups
- Experiment with different environments
- Stay current
- Get wired

### **Tip 9: Critically Analyze What You Read and Hear**
*Don't be swayed by vendors, media hype, or dogma. Analyze information in terms of you and your project.*

### **Tip 10: It's Both What You Say and the Way You Say It**
*There's no point in having great ideas if you don't communicate them effectively.*

## üîß Technical Practices

### **Tip 11: DRY‚ÄîDon't Repeat Yourself**
*Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.*

### **Tip 12: Make It Easy to Reuse**
*If it's easy to reuse, people will. Create an environment that supports reuse.*

### **Tip 13: Eliminate Effects Between Unrelated Things**
*Design components that are self-contained, independent, and have a single, well-defined purpose.*

### **Tip 14: There Are No Final Decisions**
*No decision is cast in stone. Instead, consider each as being written in the sand at the beach, and plan for change.*

### **Tip 15: Use Tracer Bullets to Find the Target**
*Tracer bullets let you home in on your target by trying things and seeing how close they land.*

## üõ†Ô∏è Tools & Automation

### **Tip 22: Use a Single Editor Well**
*The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable.*

### **Tip 23: Always Use Source Code Control**
*Source code control is a time machine for your work‚Äîyou can go back.*

### **Tip 24: Fix the Problem, Not the Blame**
*It doesn't really matter whether the bug is your fault or someone else's‚Äîit is still your problem, and it still needs to be fixed.*

### **Tip 25: Don't Panic**
*Take a deep breath and THINK! about what could be causing the symptoms that you believe indicate a bug.*

### **Tip 26: "select" Isn't Broken**
*It is rare to find a bug in the OS or the compiler, or even a third-party product or library. The bug is most likely in the application.*

### **Tip 27: Don't Assume It‚ÄîProve It**
*Prove your assumptions in the actual environment‚Äîwith real data and boundary conditions.*

## üèóÔ∏è Design & Architecture

### **Tip 28: Learn a Text Manipulation Language**
*You spend a large part of each day working with text. Why not have the computer do some of it for you?*

### **Tip 29: Write Code That Writes Code**
*Code generators increase your productivity and help protect you from duplication.*

### **Tip 30: You Can't Write Perfect Software**
*Software can't be perfect. Protect your code and users from the inevitable errors.*

### **Tip 31: Design with Contracts**
*Use contracts to document and verify that code does no more and no less than it claims to do.*

### **Tip 32: Crash Early**
*A dead program normally does a lot less damage than a crippled one.*

### **Tip 33: If It Can't Happen, Use Assertions to Ensure That It Won't**
*Assertions validate your assumptions. Use them to protect your code from an uncertain world.*

## üß™ Testing & Quality

### **Tip 48: Test Your Estimates**
*Mathematical analysis of algorithms doesn't tell you everything. Try timing your code in its target environment.*

### **Tip 49: Refactor Early, Refactor Often**
*Just as you might weed and rearrange a garden, rewrite, rework, and re-architect code when it needs it.*

### **Tip 50: Design to Test**
*Start thinking about testing before you write a line of code.*

### **Tip 51: Test Your Software, or Your Users Will**
*A ruthless testing discipline is a sure way to develop robust code.*

### **Tip 52: Don't Use Wizard Code You Don't Understand**
*Wizards can generate reams of code. Make sure you understand all of it before you incorporate it into your project.*

## üé® Pragmatic Projects

### **Tip 53: Don't Gather Requirements‚ÄîDig for Them**
*Requirements rarely lie on the surface. They're buried deep beneath layers of assumptions, misconceptions, and politics.*

### **Tip 54: Work with a User to Think Like a User**
*It's the best way to gain insight into how the system will really be used.*

### **Tip 55: Abstractions Live Longer than Details**
*Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies.*

### **Tip 56: Use a Project Glossary**
*Create and maintain a single source of all the specific terms and vocabulary for a project.*

### **Tip 57: Don't Think Outside the Box‚ÄîFind the Box**
*When faced with an impossible problem, identify the real constraints. Ask yourself: "Does it have to be done this way? Does it have to be done at all?"*

### **Tip 58: Start When You're Ready**
*You've been building experience all your life. Don't ignore niggling doubts.*

### **Tip 59: Some Things Are Better Done than Described**
*Don't fall into the specification spiral‚Äîat some point you need to start coding.*

### **Tip 60: Don't Be a Slave to Formal Methods**
*Don't blindly adopt any technique without putting it into the context of your development practices and capabilities.*

### **Tip 61: Costly Tools Don't Produce Better Designs**
*Beware of vendor hype, industry dogma, and the aura of the price tag. Judge tools on their merits.*

### **Tip 62: Organize Teams Around Functionality**
*Don't separate designers from coders, testers from data modelers. Build teams the way you build code.*

### **Tip 63: Don't Use Manual Procedures**
*A shell script or batch file will execute the same instructions, in the same order, time after time.*

### **Tip 64: Test Early. Test Often. Test Automatically.**
*Tests that run with every build are much more effective than test plans that sit on a shelf.*

### **Tip 65: Coding Ain't Done 'Til All the Tests Run**
*'Nuff said.*

### **Tip 66: Use Saboteurs to Test Your Testing**
*Introduce bugs on purpose in a separate copy of the source to verify that testing will catch them.*

### **Tip 67: Test State Coverage, Not Code Coverage**
*Identify and test significant program states. Just testing lines of code isn't enough.*

### **Tip 68: Find Bugs Once**
*Once a human tester finds a bug, it should be the last time a human tester finds that bug. Automatic tests should check for it from then on.*

### **Tip 69: English is Just a Programming Language**
*Write documents as you would write code: honor the DRY principle, use metadata, MVC, automatic generation, and so on.*

### **Tip 70: Build Documentation In, Don't Bolt It On**
*Documentation created separately from code is less likely to be correct and up to date.*

## üöÄ Quick Decision Framework

### **When You Encounter a Problem:**
1. **Don't Panic** - Take a deep breath and think
2. **Don't Assume It‚ÄîProve It** - Verify your assumptions
3. **Fix the Problem, Not the Blame** - Focus on solutions
4. **Provide Options** - Don't just say what can't be done

### **When Designing:**
1. **DRY** - Don't repeat yourself
2. **Orthogonality** - Eliminate effects between unrelated things
3. **Reversibility** - There are no final decisions
4. **Tracer Bullets** - Use prototypes to find the target

### **When Coding:**
1. **Design with Contracts** - Document preconditions and postconditions
2. **Crash Early** - Fail fast when problems are detected
3. **Use Assertions** - Validate your assumptions
4. **Refactor Early, Refactor Often** - Keep code clean

### **When Testing:**
1. **Test Early, Test Often, Test Automatically**
2. **Design to Test** - Consider testing from the start
3. **Find Bugs Once** - Write tests for every bug found
4. **Test State Coverage** - Focus on significant program states

## üí° Daily Practices

### **Every Day:**
- [ ] Question at least one assumption
- [ ] Learn something new (even if small)
- [ ] Fix at least one "broken window"
- [ ] Automate one manual task
- [ ] Review and refactor some code

### **Every Week:**
- [ ] Read technical content
- [ ] Experiment with a new tool or technique
- [ ] Share knowledge with team members
- [ ] Reflect on what worked and what didn't

### **Every Month:**
- [ ] Evaluate your knowledge portfolio
- [ ] Try a new approach to a common problem
- [ ] Update your tools and practices
- [ ] Seek feedback on your work

### **Every Quarter:**
- [ ] Learn a new technology or language
- [ ] Review and update project documentation
- [ ] Assess team practices and suggest improvements
- [ ] Plan knowledge investments for next quarter
